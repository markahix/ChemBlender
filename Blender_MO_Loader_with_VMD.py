# This program is designed to be run from inside Blender (tested with 3.3.0),
# and with access to VMD (tested with 1.9.3).  Open from the "Scripting" tab in Blender.
# The section labeled "USER_PROVIDED_VALUES" is the only thing that will need to be
# modified by the end user, but I can't really stop you if you go beyond that.
# Give this program the location of your Molden files (generated by each step of a 
# QM or QM/MM optimization or molecular dynamics simulation), and a few other parameters
# such as the orbital number you want to visualize and the colors you want to use 
# (HEX Colors ONLY). This program will process the Molden files to ensure they're all in
# phase, then render them into STL format for use in Blender (by way of VMD).  Blender 
# will load the orbitals (both phases as independent objects) and the stick structure
# for each frame, building the animation iteratively and assigning the appropriate materials.
#
# Mark A. Hix, October 31, 2022

import bpy
from glob import glob as G
import os
import numpy as np
import subprocess

### USER_PROVIDED_VALUES ###
# Where your collection of molden files are stored.
molden_path = "/home/mark/Projects/OrbitalMovies/Test_GFP_System_100steps/MoldenFilesForTesting/"

# Where you want the STL files stored (for good computational housekeeping)
STL_Filepath = molden_path+"STL_Files/"

# Where the movie will be rendered.
output_folder = "/home/mark/Documents/"  

# Orbital number you want visualized.
orbital_number = 82
 
# If you're also loading in a prmtop/dcd combo for full protein environment visualization.
prmtop = None     ### Must be None, "", or an actual filename.
trajectory = None ### Must be None, "", or an actual filename.

# doesn't really matter, but if you want to keep the file for some reason...
# idk just leave this alone tbh.  
vmd_command_file = "blender_orbital_STL.vmd"  

# Visualization Parameters
#up_orbital_color = "#a3ff00"   ## MUST BE HEX COLORS OR WAVELENGTHS (380 nm through 750 nm)
#down_orbital_color = "#ffdf00" ## MUST BE HEX COLORS OR WAVELENGTHS (380 nm through 750 nm)
up_orbital_color = 745   ## MUST BE HEX COLORS OR WAVELENGTHS (380 nm through 750 nm)
down_orbital_color = 395 ## MUST BE HEX COLORS OR WAVELENGTHS (380 nm through 750 nm)
BG_TRANSPARENT = True ### Make background transparent (good for overlays)
cycles_sampling_level = 1024 ### Ultra-high would be like 4096, but 1024 or 2048 is fine usually

# Make or Remake STL files - set to False if you already have the STL files from a previous run.
Generate_STL_Files = False


################################################################
######## NOW GO AWAY OR I SHALL TAUNT YOU A SECOND TIME ########
################################################################
## ( Seriously, these are just the functions doing the work.  You don't need this nonsense in your life. )

def generate_rgb(color):
    if type(color) == str:
        return hex_to_rgb(color)
    elif type(color) == int or type(color) == float:
        return wavelength_to_rgb(color)
    
def hex_to_rgb(hex):
    h = hex.lstrip('#')
    (r,g,b) = tuple(int(h[i:i+2], 16) for i in (0, 2, 4))
    return r/255, g/255, b/255

def wavelength_to_rgb(wavelength, gamma=0.8):
    ### Shamelessly hijacked from 
    # https://gist.github.com/error454/65d7f392e1acd4a782fc

    '''This converts a given wavelength of light to an 
    approximate RGB color value. The wavelength must be given
    in nanometers in the range from 380 nm through 750 nm
    (789 THz through 400 THz).
    Based on code by Dan Bruton
    http://www.physics.sfasu.edu/astro/color/spectra.html
    '''

    wavelength = float(wavelength)
    if wavelength >= 380 and wavelength <= 440:
        attenuation = 0.3 + 0.7 * (wavelength - 380) / (440 - 380)
        R = ((-(wavelength - 440) / (440 - 380)) * attenuation) ** gamma
        G = 0.0
        B = (1.0 * attenuation) ** gamma
    elif wavelength >= 440 and wavelength <= 490:
        R = 0.0
        G = ((wavelength - 440) / (490 - 440)) ** gamma
        B = 1.0
    elif wavelength >= 490 and wavelength <= 510:
        R = 0.0
        G = 1.0
        B = (-(wavelength - 510) / (510 - 490)) ** gamma
    elif wavelength >= 510 and wavelength <= 580:
        R = ((wavelength - 510) / (580 - 510)) ** gamma
        G = 1.0
        B = 0.0
    elif wavelength >= 580 and wavelength <= 645:
        R = 1.0
        G = (-(wavelength - 645) / (645 - 580)) ** gamma
        B = 0.0
    elif wavelength >= 645 and wavelength <= 750:
        attenuation = 0.3 + 0.7 * (750 - wavelength) / (750 - 645)
        R = (1.0 * attenuation) ** gamma
        G = 0.0
        B = 0.0
    else:
        R = 0.0
        G = 0.0
        B = 0.0
    return R, G, B

def CreateMaterial(MatName="NewMaterial",HexColor="#FFFFFF",Transmission=0.0,IOR=1.45,Roughness=0.0,EmissionColor="#000000",EmissionStrength=0,Transparency=1.0,Metallic=0.0):
    # Creating Materials is such a process.  this function makes it a little easier to do.
    # I'll likely update this in the future with the full array of material options, or 
    # alternatively create a way to just import existing materials from a library or something.
    mat = bpy.data.materials.new(name=MatName)
    mat.use_nodes=True
    mat_r,mat_g,mat_b = generate_rgb(HexColor)
    em_r,em_g,em_b = generate_rgb(EmissionColor)
    mat.node_tree.nodes["Principled BSDF"].inputs[0].default_value = (mat_r,mat_g,mat_b, 1)
    mat.node_tree.nodes["Principled BSDF"].inputs[17].default_value = Transmission
    mat.node_tree.nodes["Principled BSDF"].inputs[16].default_value = IOR
    mat.node_tree.nodes["Principled BSDF"].inputs[9].default_value = Roughness
    mat.node_tree.nodes["Principled BSDF"].inputs[19].default_value = (em_r,em_g,em_b, 1)
    mat.node_tree.nodes["Principled BSDF"].inputs[20].default_value = EmissionStrength
    mat.node_tree.nodes["Principled BSDF"].inputs[21].default_value = Transparency
    mat.node_tree.nodes["Principled BSDF"].inputs[6].default_value = Metallic
    return mat

def Get_Molecular_Orbitals(moldenfile):
    with open(moldenfile) as f:
        lines = f.readlines()
    ene_lines = []
    for i,line in enumerate(lines):
        if "Ene=" in line:
            ene_lines.append(i)
    mol_orbs = []
    n_orbs   = len(ene_lines)
    for i in range(n_orbs-1):
        orb = []
        for line in lines[ene_lines[i]+3:ene_lines[i+1]]:
            orb.append(float(line.split()[-1]))
        mol_orbs.append(orb)
    orb = []
    for line in lines[ene_lines[n_orbs-1]+3:]:
        orb.append(float(line.split()[-1]))
    mol_orbs.append(orb)
    return mol_orbs

def Get_Sign_Array(OLD_MOL_FILE,NEW_MOL_FILE):
    old_mol_orbs = Get_Molecular_Orbitals(OLD_MOL_FILE)
    new_mol_orbs = Get_Molecular_Orbitals(NEW_MOL_FILE)
    sign_array = []
    for i in range(len(old_mol_orbs)):
        sign_array.append(np.sign(np.dot(old_mol_orbs[i],new_mol_orbs[i])))
    return sign_array

def Write_Phase_Swapped_Molden(moldenfile,sign_array):
    with open(moldenfile) as f:
        newlines = f.readlines()
    with open(moldenfile,"w") as f:
        for i,line in enumerate(newlines):
            f.write(line)
            if "[MO]" in line:
                break
        start_mo_lines = i+1
        ene_lines_encountered = -1
        for line in newlines[start_mo_lines:]:
            if "Ene=" in line:
                ene_lines_encountered += 1
                f.write(line)
            elif "Spin=" in line:
                f.write(line)
            elif "Occup=" in line:
                f.write(line)
            else:
                templine = line.split()
                if sign_array[ene_lines_encountered] == -1:
                    if "-" in templine[1]:
                        templine[1] = templine[1].replace("-"," ")
                    else:
                        templine[1] = "-"+templine[1].strip()
                newline = f"{templine[0]:>5}{float(templine[1]):>11.05f}\n"
                f.write(newline)

def VMDInitialize(inputfilename):
    with open(inputfilename,"w") as f:
        f.write("display update on\n")
        f.write("color add item Display Background white\n")
        f.write("color Display Background white\n")
        f.write("display projection perspective \n")
        f.write("display culling off\n")
        f.write("axes location off\n")
        f.write("display rendermode Normal\n")
        f.write("display depthcue off\n")
        f.write("display resize 1920 1080\n")
    return None

def VMDLoadMoldens(vmdcommandfile,ORDERED_MOLDEN_FILELIST,orbital_number):
    with open(vmdcommandfile,"a") as f:
        num_moldens_loaded = 0
        for moldenfile in ORDERED_MOLDEN_FILELIST:
            if num_moldens_loaded == 0:
                f.write(f"mol new {moldenfile} type molden first 0 last -1 step 1 filebonds 1 autobonds 1 waitfor all\n")
            else:
                f.write(f"mol addfile {moldenfile} type molden first 0 last -1 step 1 filebonds 1 autobonds 1 waitfor all\n")
            num_moldens_loaded += 1
        f.write("mol delrep 0 top\n")
        f.write("mol representation Licorice 0.100000 30.000000 30.000000\n")
        f.write("mol selection {all}\n")
        f.write("mol addrep top\n")
        f.write("mol selupdate 0 top 0\n")
        f.write("mol colupdate 0 top 0\n")
        f.write("mol scaleminmax top 0 0.000000 0.000000\n")
        f.write("mol smoothrep top 0 0\n")
        f.write("mol drawframes top 0 {now}\n")
        f.write(f"mol representation Orbital 0.050000 {orbital_number} 0 0 0.050 1 6 0 0 1\n")
        f.write("mol selection {all}\n")
        f.write(f"mol addrep top\n")
        f.write(f"mol selupdate 1 top 0\n")
        f.write(f"mol colupdate 1 top 0\n")
        f.write(f"mol scaleminmax top 1 0.000000 0.000000\n")
        f.write(f"mol smoothrep top 1 0\n")
        f.write("mol drawframes top 1 {now}\n")
        f.write(f"mol representation Orbital -0.050000 {orbital_number} 0 0 0.050 1 6 0 0 1\n")
        f.write("mol selection {all}\n")
        f.write(f"mol addrep top\n")
        f.write(f"mol selupdate 1 top 0\n")
        f.write(f"mol colupdate 1 top 0\n")
        f.write(f"mol scaleminmax top 1 0.000000 0.000000\n")
        f.write(f"mol smoothrep top 1 0\n")
        f.write("mol drawframes top 1 {now}\n")
        f.write("mol showrep top 0 0\n")
        f.write("mol showrep top 1 0\n")
        f.write("mol showrep top 2 0\n")
        
def MoldenPhaseChecker(molden_location):
    ORDERED_MOLDEN_FILELIST=[]
    startdir = os.getcwd()
    os.chdir(molden_location)
    file_list = G("*.molden.*")
    file_list.sort(key=os.path.getmtime)
    n_moldens = len(file_list)
    os.makedirs("phased_molden_files/",exist_ok=True)
    os.system(f"cp *.molden.* phased_molden_files/")
    for i in range(n_moldens-1):
        OLD_MOL_FILE="phased_molden_files/"+file_list[i]
        NEW_MOL_FILE="phased_molden_files/"+file_list[i+1]
        sign_array = Get_Sign_Array(OLD_MOL_FILE,NEW_MOL_FILE)
        Write_Phase_Swapped_Molden(NEW_MOL_FILE,sign_array)
        ORDERED_MOLDEN_FILELIST.append(os.path.abspath(OLD_MOL_FILE))
    ORDERED_MOLDEN_FILELIST.append(os.path.abspath(NEW_MOL_FILE))
    os.chdir(startdir)
    return ORDERED_MOLDEN_FILELIST


def VMDLoadProtein(inputfilename,prmtop,trajectory):
    with open(inputfilename,"a") as f:
        f.write(f"mol new {prmtop} type parm7 first 0 last -1 step 1 filebonds 1 autobonds 1 waitfor all\n")
        f.write(f"mol addfile {trajectory} type dcd first 0 last -1 step 1 filebonds 1 autobonds 1 waitfor all\n")
        f.write(f"mol delrep 0 top\n")
        f.write(f"mol representation NewCartoon 0.300000 20.000000 4.100000 0\n")
        f.write(f"mol addrep top\n")
        f.write(f"mol selupdate 0 top 0\n")
        f.write(f"mol colupdate 0 top 0\n")
        f.write(f"mol scaleminmax top 0 0.000000 0.000000\n")
        f.write(f"mol smoothrep top 0 0\n")
        f.write("mol drawframes top 0 {now}\n")
        f.write("mol showrep top 0 0\n")
        
def VMDOrbitalstoSTLs(inputfilename):
    with open(inputfilename,"a") as f:
        f.write("""proc make_orbital_STL_files {} {
set num [molinfo top get numframes]
for {set i 0} {$i < $num} {incr i 1} {
animate goto $i
display update
# render licorice STL
set filename """+STL_Filepath+"""Frame_[format "%05d" [expr $i/1]]_Licorice.stl
mol showrep 0 0 1
render STL $filename true
mol showrep 0 0 0

# render Phase-Up STL
set filename """+STL_Filepath+"""Frame_[format "%05d" [expr $i/1]]_Phase_Up.stl
mol showrep 0 1 1
render STL $filename true
mol showrep 0 1 0

# render Phase-Down STL
set filename """+STL_Filepath+"""Frame_[format "%05d" [expr $i/1]]_Phase_Down.stl
mol showrep 0 2 1
render STL $filename true
mol showrep 0 2 0
}
}
make_orbital_STL_files
""")
        
def VMDProteintoSTLs(inputfilename):
    with open(inputfilename,"a") as f:
        f.write("""proc make_protein_STL_files {} {
set num [molinfo top get numframes]
for {set i 0} {$i < $num} {incr i 1} {
animate goto $i
display update
# render NewCartoon Protein STL
set filename """+STL_Filepath+"""Frame_[format "%05d" [expr $i/1]]_NewCartoon.stl
mol showrep 1 0 1
render STL $filename true
mol showrep 1 0 0
}
}
make_protein_STL_files
""")

def VMD_Job_Writer(moldenfiles,orbitalnumber,prmtop=None,trajectory=None,vmdcommandfile="orbital_trajectory.vmd"):
    ORDERED_MOLDEN_FILELIST = MoldenPhaseChecker(moldenfiles)
    VMDInitialize(vmdcommandfile)
    VMDLoadMoldens(vmdcommandfile,ORDERED_MOLDEN_FILELIST,orbitalnumber)
    if prmtop != None and trajectory != None:
        VMDLoadProtein(vmdcommandfile,prmtop,trajectory)
    VMDOrbitalstoSTLs(vmdcommandfile)
    if prmtop != None and trajectory != None:
        VMDProteintoSTLs(vmdcommandfile)
    with open(vmdcommandfile,"a") as f:
        f.write("quit\n")
    
### Add Material to Object, with quick check.
def AddMaterialToObject(obj,mat):
    if obj.data.materials:
        # assign to 1st material slot
        obj.data.materials[0] = mat
    else:
        # no slots
        obj.data.materials.append(mat)

### Show the object for exactly one frame
def HideObjectKeyframe(obj,frame_number):
    # Hide the object from the start of the scene until the desired frame number
    # Keyframes from 0 to T-1 to ensure it remains hidden the entire time.
    obj.hide_render = True
    obj.keyframe_insert(data_path="hide_render",frame=0)
    obj.keyframe_insert(data_path="hide_render",frame=frame_number-1)
    # Display the object for frame T and save keyframe.
    obj.hide_render = False
    obj.keyframe_insert(data_path="hide_render",frame=frame_number)
    # Hide object again at frame T+1 and save keyframe.
    obj.hide_render = True
    obj.keyframe_insert(data_path="hide_render",frame=frame_number+1)
    
def LoadSTLwithMaterial(STL_file,material):
    name = STL_file.split("/")[-1].replace(".stl","")
    bpy.ops.import_mesh.stl(filepath=STL_file)
    curr_scene = bpy.context.scene
    obj = curr_scene.objects[name]
    AddMaterialToObject(obj,material)
    return obj

def SubdivideSurface():
    bpy.ops.object.modifier_add(type='SUBSURF')
    bpy.context.object.modifiers["Subdivision"].levels = 0
    bpy.context.object.modifiers["Subdivision"].render_levels = 2


### BEGIN PROCESSING
fullpath = os.path.abspath(molden_path)
STL_Folder = os.path.abspath(STL_Filepath)
Use_NewC = False
if all([prmtop != None,prmtop!="",trajectory != None,trajectory!=""]):
    Use_NewC = True
    

if Generate_STL_Files:
    VMD_Job_Writer(fullpath, int(orbital_number), prmtop=prmtop,trajectory=trajectory, vmdcommandfile=vmd_command_file)
    
    ## Run VMD Command File with VMD.
    subprocess.call(f"mkdir -p {STL_Folder}",shell=True)
    subprocess.call(f"vmd -e {vmd_command_file}",shell=True)

LIC_FILES   = G(STL_Folder + "/*Licorice.stl")
LIC_FILES.sort(key=os.path.getmtime)
UP_FILES    = G(STL_Folder + "/*Phase_Up.stl")
UP_FILES.sort(key=os.path.getmtime)
DOWN_FILES  = G(STL_Folder + "/*Phase_Down.stl")
DOWN_FILES.sort(key=os.path.getmtime)
if Use_NewC:
    NEWC_FILES  = G(STL_Folder + "/*NewCartoon.stl")
    n_files = min(len(LIC_FILES),len(UP_FILES),len(DOWN_FILES),len(NEWC_FILES))
else:
    n_files = min(len(LIC_FILES),len(UP_FILES),len(DOWN_FILES))

### Define necessary materials
# NewCartoon Material
NewC_Mat  = CreateMaterial(MatName="NewCartoon Material",HexColor="#00FF00",Metallic=0.6,Transparency=0.3,Transmission=1.0)

# Licorice Material
Lic_Mat  = CreateMaterial(MatName="Licorice_Material",Roughness=0.0,Metallic=0.6)

# Phase Up Material
Up_Mat   = CreateMaterial(MatName="Phase_Up_Material",
               HexColor=up_orbital_color,
               Transmission=1.0,
               IOR=1.05,
               Roughness=0.0,
               EmissionColor=up_orbital_color,
               EmissionStrength=0.2,
               Transparency=0.5)

# Phase Down Material
Down_Mat = CreateMaterial(MatName="Phase_Down_Material",
               HexColor=down_orbital_color,
               Transmission=1.0,
               IOR=1.05,
               Roughness=0.0,
               EmissionColor=down_orbital_color,
               EmissionStrength=0.2,
               Transparency=0.5)    

### Make Background transparent (good for overlays)
bpy.context.scene.render.film_transparent = BG_TRANSPARENT

### Output Format and Filepath
bpy.context.scene.render.image_settings.file_format = 'FFMPEG'
bpy.context.scene.render.filepath = output_folder

### Set Animation end frame to n_frames
bpy.context.scene.frame_end = n_files

### Set Renderer to Cycles with GPU support
bpy.context.scene.render.engine = 'CYCLES'
bpy.context.scene.cycles.samples = cycles_sampling_level
bpy.context.scene.cycles.device = 'GPU'

### Run through all STL files from the VMD STL Generator Script
for i in range(n_files):
    print("Loading File #",i,"in sequence...")
    # Load STL file with Material
    curr_lic = LoadSTLwithMaterial(LIC_FILES[i],Lic_Mat)
    SubdivideSurface()
    curr_up = LoadSTLwithMaterial(UP_FILES[i],Up_Mat)
    curr_down = LoadSTLwithMaterial(DOWN_FILES[i],Down_Mat)     
    
    ### Show object only on relevant frame number.
    HideObjectKeyframe(curr_lic,i+1)    
    HideObjectKeyframe(curr_up,i+1)
    HideObjectKeyframe(curr_down,i+1)
    
    # Only if using New Cartoon STL (from protein)
    if Use_NewC:
        curr_newc = LoadSTLwithMaterial(NEWC_FILES[i],Lic_Mat)
        HideObjectKeyframe(curr_newc,i+1)
